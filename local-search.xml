<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>你好，我的个人介绍？</title>
    <link href="/pingpinghome/2025/08/20/hello-world/"/>
    <url>/pingpinghome/2025/08/20/hello-world/</url>
    
    <content type="html"><![CDATA[<p>欢迎来到我的个人博客，本博客主要用于个人学习和笔记展示，方便浏览一路走过来的点点滴滴，如果你有兴趣和我交流，请在github中搜索pink-pigpig给我留言。顺便测试一下链接<a href="https://github.com/pink-pigpig">我的github</a></p><h2 id="简单说一些">简单说一些</h2><h3 id="一些碎碎念">一些碎碎念</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">测试一下代码块是不是有高亮显示liang<br></code></pre></td></tr></table></figure><h3 id="目前安排">目前安排</h3><ul><li>[x] 前端vue3</li><li>[x] 后端springBoot</li><li>[x] 学习前端相关组件——router、vue3、vuex、axios、element</li><li>[x] 学习后端相关组件——springBoot、mybatis、jwt、redis、</li><li>[x] 语言：java、javascript、html、css、sql、TypeScript、mysql、微信小程序</li><li>[ ] 目前其他想要学习的东西：jpa（听说和redis差不多，且看）</li><li>[ ] 学习方向：ai方向的自动化开发流线（未接触，先写着。）</li></ul><h3 id="目前的项目">目前的项目</h3><h4 id="赛诺公司——访客管理系统">赛诺公司——访客管理系统</h4><ul><li>vue3，springBoot，mybatis，jwt，redis，element，axios，oss，typescript，mysql等</li></ul><blockquote><p>一款由赛诺公司牵头，提供需求文档，从零开始开发的项目。项目涉及软硬件管理，前后端开发，旨在全面考察个人开发能力。<br>这个项目是我第一次全栈开发的测试，独自完成前后端的所有开发，虽然项目不大，但一整套流程下来，对很多东西都有了感悟，比如，为什么需要前后端的接口文档、数据库设计、技术选型？为什么需要开发规范？以及为什么前后端需要沟通才可以顺利推进项目等。很多东西，只有自己完全去接触后才会有所理解。</p><blockquote><p>特别感谢我这个项目的搭档，陪我一起体会，一人前端一人后端，模拟整个开发的流程。</p></blockquote></blockquote><hr><ol><li>从零自主搭建项目，运用vue3加element来实现前端页面的展示，运用SpringBoot快速开发后端。</li><li>从零开始设计需求文档，项目接口文档，数据库表设计，根据文档开发等，熟悉项目开发流程，对开发流程有深刻理解。</li><li>前端利用axios与nodejs来进行网络请求和服务代理，运用element实现图像展示，文件上传等功能。运用vue和ts语言来更好的实现对应的功能。</li><li>后端运用jwt来进行拦截，实现用户鉴权，通过对token的验证来防止未授权访问</li><li>运用aop来进行切面类开发，实现对通用字段的自动填写，和对接口的处理时间统计。通过redis来对一些频繁访问的数据进行缓存，减少对数据库的压力，同时对验证码这类时效性信息设计过期时间，提高系统安全性</li><li>运用MyBatis对数据库进行操作，实现数据存储功能。</li></ol><hr><h4 id="粉猪博客">粉猪博客</h4><ul><li>Vue、axios、ElementUI、vue-echarts、mavon-editor、vue-router、SpringBoot、SpringSecurity、MyBatis、部分接口遵循Restful风格、MySQL</li></ul><blockquote><p>这个项目是我一直以来想做的，我认为这是一个很适合我开始的项目，可以记录自己一路学习的过程，也可以分享一些自己的事，顺便学习一下新的技术和开发方式。</p></blockquote><p>1.对与这个项目我想大家见怪不怪了，vue和springboot都是很熟悉的东西，所以学习起来很简单。<br>2.这次学习主要是在部署和怎么把网页托管上，我用的是gitpage，和hexo来进行搭建，所以过程很顺利。<br>3.学习用SpringSecurity来进行认证，学习用jpa来进行数据库操作。一方面是之前学的jwt有点区别，另一方面mybatis和jpa的用法也一样，所以学习起来很轻松。两者思想有所区别，但是很相似。<br>4.这个项目边做边学，日后会成为个人笔记和补充，后面添加新的项目也会在这里提一下。</p><h3 id="学习路程">学习路程</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HttpClient学习与使用</title>
    <link href="/pingpinghome/2025/08/12/HttpClient%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/pingpinghome/2025/08/12/HttpClient%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1>HttpClient</h1><h2 id="一、简单入门">一、简单入门</h2><h3 id="1、介绍">1、介绍</h3><p>HttpClient 是Apache Jakarta Common 下的子项目，可以用来提供高效的、最新的、功能丰富的支持 HTTP 协议的客户端编程工具包，并且它支持 HTTP 协议最新的版本和建议。</p><p><strong>HttpClient作用：</strong></p><ul><li><p>发送HTTP请求</p></li><li><p>接收响应数据</p></li></ul><p>❓为什么要在Java程序中发送Http请求？有哪些应用场景呢？</p><p><strong>HttpClient应用场景：</strong></p><p>✅ 当我们在使用扫描支付、查看地图、获取验证码、查看天气等功能时</p><p>其实，应用程序本身并未实现这些功能，都是在应用程序里访问提供这些功能的服务，访问这些服务需要发送HTTP请求，并且接收响应数据，可通过HttpClient来实现。</p><p><strong>HttpClient的maven坐标：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>HttpClient的核心API：</strong></p><ul><li>HttpClient：Http客户端对象类型，使用该类型对象可发起Http请求。</li><li>HttpClients：可认为是构建器，可创建HttpClient对象。</li><li>CloseableHttpClient：实现类，实现了HttpClient接口。</li><li>HttpGet：Get方式请求类型。</li><li>HttpPost：Post方式请求类型。</li></ul><p><strong>HttpClient发送请求步骤：</strong></p><ul><li>创建HttpClient对象</li><li>创建Http请求对象</li><li>调用HttpClient的execute方法发送请求</li></ul><h2 id="二、使用步骤">二、使用步骤</h2><h3 id="1-简单使用">1.简单使用</h3><ul><li>第一步，HttpClient创建客户端对象，用来发起http请求</li><li>第二步，创建请求对象填入地址</li><li>第三步，Http发送请求</li><li>第四步，HttpClient的execute接收请求</li><li>最后，记得关闭使用的资源</li></ul><h3 id="2-入门案例">2.入门案例</h3><h4 id="2-1-get请求">2.1 get请求</h4><p>正常来说，首先，应该导入HttpClient相关的坐标，但在项目中，就算不导入，也可以使用相关的API。</p><p>因为在项目中已经引入了aliyun-sdk-oss坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.aliyun.oss<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aliyun-sdk-oss<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述依赖的底层已经包含了HttpClient相关依赖。</p><p>如果你的项目没有使用，可以用下面这个依赖。</p><p><strong>HttpClient的maven坐标：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>实现步骤：</strong></p><ol><li>创建HttpClient对象</li><li>创建请求对象</li><li>发送请求，接受响应结果</li><li>解析结果</li><li>关闭资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.test;<br><br><span class="hljs-keyword">import</span> org.apache.http.HttpEntity;<br><span class="hljs-keyword">import</span> org.apache.http.client.methods.CloseableHttpResponse;<br><span class="hljs-keyword">import</span> org.apache.http.client.methods.HttpGet;<br><span class="hljs-keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;<br><span class="hljs-keyword">import</span> org.apache.http.impl.client.HttpClients;<br><span class="hljs-keyword">import</span> org.apache.http.util.EntityUtils;<br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpClientTest</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试通过httpclient发送GET方式的请求</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testGET</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>        <span class="hljs-comment">//创建httpclient对象</span><br>        <span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><br>        <span class="hljs-comment">//创建请求对象 http://localhost:8080/user/shop/status</span><br>        <span class="hljs-type">HttpGet</span> <span class="hljs-variable">httpGet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpGet</span>(<span class="hljs-string">&quot;请求地址&quot;</span>);<br><br>        <span class="hljs-comment">//发送请求，接受响应结果</span><br>        <span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpClient.execute(httpGet);<br><br>        <span class="hljs-comment">//获取服务端返回的状态码 200</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> response.getStatusLine().getStatusCode();<br>        System.out.println(<span class="hljs-string">&quot;服务端返回的状态码为：&quot;</span> + statusCode);<br><br>        <span class="hljs-comment">//获取服务端放回的数据体 &#123;&quot;code&quot;:1,&quot;msg&quot;,null,&quot;data&quot;:1&#125;</span><br>        <span class="hljs-type">HttpEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> response.getEntity();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> EntityUtils.toString(entity);<br>        System.out.println(<span class="hljs-string">&quot;服务端返回的数据为：&quot;</span> + body);<br><br>        <span class="hljs-comment">//关闭资源</span><br>        response.close();<br>        httpClient.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-post请求">2.2 post请求</h4><p>在HttpClientTest中添加POST方式请求方法，相比GET请求来说，POST请求若携带参数需要封装请求体对象，并将该对象设置在请求对象中。</p><p><strong>实现步骤：</strong></p><ol><li>创建HttpClient对象</li><li>创建请求对象</li><li>发送请求，接收响应结果</li><li>解析响应结果</li><li>关闭资源</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 测试通过httpclient发送POST方式的请求</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testPOST</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception&#123;<br>       <span class="hljs-comment">// 创建httpclient对象</span><br>       <span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> HttpClients.createDefault();<br><br>       <span class="hljs-comment">//创建请求对象</span><br>       <span class="hljs-type">HttpPost</span> <span class="hljs-variable">httpPost</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpPost</span>(<span class="hljs-string">&quot;http://localhost:8080/admin/employee/login&quot;</span>);<br><br>       <span class="hljs-type">JSONObject</span> <span class="hljs-variable">jsonObject</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JSONObject</span>();<br>       jsonObject.put(<span class="hljs-string">&quot;username&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>);<br>       jsonObject.put(<span class="hljs-string">&quot;password&quot;</span>,<span class="hljs-string">&quot;123456&quot;</span>);<br><br>       <span class="hljs-type">StringEntity</span> <span class="hljs-variable">entity</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringEntity</span>(jsonObject.toString());<br>       <span class="hljs-comment">//指定请求编码方式</span><br>       entity.setContentEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>);<br>       <span class="hljs-comment">//数据格式</span><br>       entity.setContentType(<span class="hljs-string">&quot;application/json&quot;</span>);<br>       httpPost.setEntity(entity);<br><br>       <span class="hljs-comment">//发送请求</span><br>       <span class="hljs-type">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> httpClient.execute(httpPost);<br><br>       <span class="hljs-comment">//解析返回结果</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">statusCode</span> <span class="hljs-operator">=</span> response.getStatusLine().getStatusCode();<br>       System.out.println(<span class="hljs-string">&quot;响应码为：&quot;</span> + statusCode);<br><br>       <span class="hljs-type">HttpEntity</span> <span class="hljs-variable">entity1</span> <span class="hljs-operator">=</span> response.getEntity();<br>       <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> EntityUtils.toString(entity1);<br>       System.out.println(<span class="hljs-string">&quot;响应数据为：&quot;</span> + body);<br><br>       <span class="hljs-comment">//关闭资源</span><br>       response.close();<br>       httpClient.close();<br>   &#125;<br></code></pre></td></tr></table></figure><p>httpclient的入门很简单，之后的进阶使用会进一步说明。</p>]]></content>
    
    
    <categories>
      
      <category>入门知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>入门知识</tag>
      
      <tag>HttpClient</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis的学习与使用</title>
    <link href="/pingpinghome/2025/08/12/Redis%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/pingpinghome/2025/08/12/Redis%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1>redis学习与使用</h1><h2 id="一、入门">一、入门</h2><h3 id="1-概念">1.概念</h3><p>redis是一种数据库，但与一般的数据库不同，采用的是键值对来进行存储，他是在内存当中工作的，所以速度比较快。</p><ul><li>适用于在一些热点数据上使用，减少数据库的压力</li><li>企业用的比较多</li><li>基于内存存储，读写性能高</li></ul><h3 id="2-redis的下载和安装">2.redis的下载和安装</h3><p>github下载连接<a href="https://github.com/redis-windows/redis-windows">redis-windows/redis-windows: Redis 6.0.20 6.2.18 7.0.15 7.2.8 7.4.3 8.0.0 for Windows — redis-windows/redis-windows: Redis 6.0.20 6.2.18 7.0.15 7.2.8 7.4.3 8.0.0 for Windows</a></p><p>其他教程<a href="https://blog.csdn.net/weixin_44893902/article/details/123087435">Window下Redis的安装和部署详细图文教程（Redis的安装和可视化工具的使用）_redis安装-CSDN博客</a></p><h3 id="3-需要注意的几个文件">3.需要注意的几个文件</h3><ul><li>conf配置文件</li><li>cli连接客户端</li><li>server启动服务</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">&gt;redis-cli<span class="hljs-selector-class">.exe</span> -h <span class="hljs-number">1</span>ocalhost -<span class="hljs-selector-tag">p</span> <span class="hljs-number">6379</span><br></code></pre></td></tr></table></figure><p>通过此命令指定连接的地址和端口</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">redis</span>-cli.exe -h <span class="hljs-number">1</span>ocalhost -p6379-a <span class="hljs-number">123456</span><br></code></pre></td></tr></table></figure><p>如果设置了密码，则需要在后面添加-a 密码</p><p>密码设置直接在conf上修改，其他操作直接查看官方</p><p><a href="https://www.redis.net.cn/">Redis中文网</a></p><h2 id="二、常用的用法">二、常用的用法</h2><h3 id="2-1redis常用数据类型">2.1redis常用数据类型</h3><ul><li><p>分类</p><ul><li>字符串 string</li><li>哈希 hash</li><li>列表 list</li><li>集合 set</li><li>有序集合 sorted set / zset</li></ul></li><li><p>特点</p><ul><li>字符串(string)：普通字符串，Redis中最简单的数据类型</li><li>哈希(hash)：也叫散列，类似于Java中的HashMap结构</li><li>列表(list)：按照插入顺序排序，可以<strong>有重复</strong>元素，类似于Java中的LinkedList</li><li>集合(set)：无序集合，<strong>没有重复元素</strong>，类似于Java中的HashSet</li><li>有序集合(sorted set/zset)：集合中每个元素关联一个分数(score)，根据分数<strong>升序排序，没有重复元素</strong></li></ul></li></ul><h2 id="三、Redis常用命令">三、Redis常用命令</h2><h3 id="3-1字符串操作命令">3.1字符串操作命令</h3><p>Redis 中字符串类型常用命令：</p><table><thead><tr><th>字符串类型常用</th><th style="text-align:center"></th></tr></thead><tbody><tr><td><strong>SET</strong> key value</td><td style="text-align:center">设置指定key的值</td></tr><tr><td><strong>GET</strong> key</td><td style="text-align:center">获取指定key的值</td></tr><tr><td><strong>SETEX</strong> key seconds value</td><td style="text-align:center">设置指定key的值，并将 key 的过期时间设为 seconds 秒</td></tr><tr><td><strong>SETNX</strong> key value</td><td style="text-align:center">只有在 key    不存在时设置 key 的值</td></tr></tbody></table><p>更多命令可以参考Redis中文网：<a href="https://www.redis.net.cn">https://www.redis.net.cn</a></p><h3 id="3-2哈希操作命令">3.2哈希操作命令</h3><p>Redis hash 是一个string类型的 field 和 value 的映射表，hash特别适合用于<strong>存储对象</strong>，常用命令：</p><p>📖<strong>需要注意的是</strong>：key是表格，field是字段，value是字段的值。</p><table><thead><tr><th>哈希类型常用命令</th><th></th></tr></thead><tbody><tr><td><strong>HSET</strong> key field value</td><td>将哈希表 key 中的字段 field 的值设为 value</td></tr><tr><td><strong>HGET</strong> key field</td><td>获取存储在哈希表中指定字段的值</td></tr><tr><td><strong>HDEL</strong> key field</td><td>删除存储在哈希表中的指定字段</td></tr><tr><td><strong>HKEYS</strong> key</td><td>获取哈希表中所有字段</td></tr><tr><td><strong>HVALS</strong> key</td><td>获取哈希表中所有值</td></tr></tbody></table><h3 id="3-3列表操作命令">3.3列表操作命令</h3><p>Redis 列表是简单的字符串列表，按照插入<strong>顺序排序</strong>，常用命令：</p><p>📘**例子：**插入abcd，则在队列中，是dcba。a在尾部，d在头部。</p><table><thead><tr><th>列表操作命令</th><th></th></tr></thead><tbody><tr><td><strong>LPUSH</strong> key value1 [value2]</td><td>将一个或多个值插入到列表头部</td></tr><tr><td><strong>LRANGE</strong> key start stop</td><td>获取列表指定范围内的元素</td></tr><tr><td><strong>RPOP</strong> key</td><td>移除并获取列表最后一个元素</td></tr><tr><td><strong>LLEN</strong> key</td><td>获取列表长度</td></tr><tr><td><strong>BRPOP</strong> key1 [key2 ] timeout</td><td>移出并获取列表的最后一个元素， 如果列表没有元素会阻塞列表直到等待超    时或发现可弹出元素为止</td></tr></tbody></table><h3 id="3-4-集合操作命令">3.4 集合操作命令</h3><p>Redis set 是string类型的无序集合。集合成员是<strong>唯一的</strong>，这就意味着集合中 不能出现重复的数据，常用命令：</p><p>📖 可以通过集合的特性来进行运算，比如交集可以求共同数据。</p><table><thead><tr><th>集合操作命令</th><th></th></tr></thead><tbody><tr><td><strong>SADD</strong> key member1 [member2]</td><td>向集合添加一个或多个成员</td></tr><tr><td><strong>SMEMBERS</strong> key</td><td>返回集合中的所有成员</td></tr><tr><td><strong>SCARD</strong> key</td><td>获取集合的成员数</td></tr><tr><td><strong>SINTER</strong> key1 [key2]</td><td>返回给定所有集合的交集</td></tr><tr><td><strong>SUNION</strong> key1 [key2]</td><td>返回所有给定集合的并集</td></tr><tr><td><strong>SREM</strong> key member1 [member2]</td><td>移除集合中一个或多个成员</td></tr></tbody></table><h3 id="3-5-有序集合操作命令">3.5 有序集合操作命令</h3><p>Redis<strong>有序</strong>集合是string类型元素的集合，且<strong>不允许有重复</strong>成员。每个元素都会关联一个double类型的分数。常用命令：</p><p>常用命令：</p><table><thead><tr><th>有序集合操作命令</th><th></th></tr></thead><tbody><tr><td><strong>ZADD</strong> key score1 member1 [score2 member2]</td><td>向有序集合添加一个或多个成员</td></tr><tr><td><strong>ZRANGE</strong> key start stop [WITHSCORES]</td><td>通过索引区间返回有序集合中指定区间内的成员</td></tr><tr><td><strong>ZINCRBY</strong> key increment member</td><td>有序集合中对指定成员的分数加上增量 increment</td></tr><tr><td><strong>ZREM</strong> key member [member …]</td><td>移除有序集合中的一个或多个成员</td></tr></tbody></table><h3 id="3-6-通用命令">3.6 通用命令</h3><p>Redis的通用命令是不分数据类型的，都可以使用的命令：</p><ul><li>KEYS pattern 查找所有符合给定模式( pattern)的 key</li><li>EXISTS key 检查给定 key 是否存在</li><li>TYPE key 返回 key 所储存的值的类型</li><li>DEL key 该命令用于在 key 存在是删除 key</li></ul><p>💡<strong>提示</strong>：可以通过 0 -1 的方式来遍历整个表格</p><p>💡<strong>笔记</strong>：同样兼容“ * ”来进行查询比如用keys set*就可以查询到所有set开头的key。</p><h2 id="四、在java中操作redis">四、在java中操作redis</h2><h3 id="4-1redis的java客户端">4.1redis的java客户端</h3><p>Redis 的 Java 客户端很多，常用的几种：</p><ul><li>Jedis</li><li>Lettuce</li><li>Spring Data Redis</li></ul><p>我这里用的是<strong>Spring Data Redis</strong></p><h3 id="4-2Spring-Data-Redis使用方式">4.2Spring Data Redis使用方式</h3><p>Spring Data Redis 是 Spring 的一部分，提供了在 Spring 应用中通过简单的配置就可以访问 Redis 服务，对 Redis 底层开发包进行了高度封装。在 Spring 项目中，可以使用Spring Data Redis来简化 Redis 操作。</p><p>网址：<a href="https://spring.io/projects/spring-data-redis">https://spring.io/projects/spring-data-redis</a></p><p>Spring Boot提供了对应的Starter，maven坐标：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Spring Data Redis中提供了一个高度封装的类：<strong>RedisTemplate</strong>，对相关api进行了归类封装,将同一类型操作封装为operation接口，具体分类如下：</p><ul><li>ValueOperations：string数据操作</li><li>SetOperations：set类型数据操作</li><li>ZSetOperations：zset类型数据操作</li><li>HashOperations：hash类型的数据操作</li><li>ListOperations：list类型的数据操作</li></ul><h3 id="4-3使用步骤">4.3使用步骤</h3><h4 id="4-3-1导入坐标">4.3.1导入坐标</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-3-2配置">4.3.2配置</h4><p><strong>解释说明：</strong></p><p>database:指定使用Redis的哪个数据库，Redis服务启动后默认有16个数据库，编号分别是从0到15。</p><p>可以通过修改Redis配置文件来指定数据库的数量。</p><p>在application.yml中添加读取application-dev.yml中的相关Redis配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">$&#123;sky.redis.host&#125;</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-string">$&#123;sky.redis.port&#125;</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">$&#123;sky.redis.password&#125;</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-string">$&#123;sky.redis.database&#125;</span><br></code></pre></td></tr></table></figure><p>在application-dev.yml中添加</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">sky:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-comment">#没有设置密码的话不需要设置</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-comment">#默认是10</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><h4 id="4-3-3配置类">4.3.3配置类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.config;<br><br><span class="hljs-keyword">import</span> lombok.extern.slf4j.Slf4j;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.connection.RedisConnectionFactory;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.RedisTemplate;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.serializer.StringRedisSerializer;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedisConfiguration</span> &#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RedisTemplate <span class="hljs-title function_">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span>&#123;<br>        log.info(<span class="hljs-string">&quot;开始创建redis模板对象...&quot;</span>);<br>        <span class="hljs-type">RedisTemplate</span> <span class="hljs-variable">redisTemplate</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RedisTemplate</span>();<br>        <span class="hljs-comment">//设置redis的连接工厂对象</span><br>        redisTemplate.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-comment">//设置redis key的序列化器</span><br>        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> <span class="hljs-title class_">StringRedisSerializer</span>());<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>解释说明：</strong></p><p>当前配置类不是必须的，因为 Spring Boot 框架会自动装配 RedisTemplate 对象，但是默认的key序列化器为</p><p>JdkSerializationRedisSerializer，导致我们存到Redis中后的数据和原始数据有差别，故设置为</p><p>StringRedisSerializer序列化器。</p><h4 id="4-3-4通过RedisTemplate对象操作Redis">4.3.4通过RedisTemplate对象操作Redis</h4><p>在test下新建测试类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sky.test;<br><br><span class="hljs-keyword">import</span> org.junit.jupiter.api.Test;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.data.redis.core.*;<br><br><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SpringDataRedisTest</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testRedisTemplate</span><span class="hljs-params">()</span>&#123;<br>        System.out.println(redisTemplate);<br>        <span class="hljs-comment">//string数据操作</span><br>        <span class="hljs-type">ValueOperations</span> <span class="hljs-variable">valueOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForValue();<br>        <span class="hljs-comment">//hash类型的数据操作</span><br>        <span class="hljs-type">HashOperations</span> <span class="hljs-variable">hashOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForHash();<br>        <span class="hljs-comment">//list类型的数据操作</span><br>        <span class="hljs-type">ListOperations</span> <span class="hljs-variable">listOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForList();<br>        <span class="hljs-comment">//set类型数据操作</span><br>        <span class="hljs-type">SetOperations</span> <span class="hljs-variable">setOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForSet();<br>        <span class="hljs-comment">//zset类型数据操作</span><br>        <span class="hljs-type">ZSetOperations</span> <span class="hljs-variable">zSetOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForZSet();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-3-操作常见类型数据">4.2.3 操作常见类型数据</h4><p><strong>1). 操作字符串类型数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 操作字符串类型的数据</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testString</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-comment">// set get setex setnx</span><br>       redisTemplate.opsForValue().set(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;小明&quot;</span>);<br>       <span class="hljs-type">String</span> <span class="hljs-variable">city</span> <span class="hljs-operator">=</span> (String) redisTemplate.opsForValue().get(<span class="hljs-string">&quot;name&quot;</span>);<br>       System.out.println(city);<br>       redisTemplate.opsForValue().set(<span class="hljs-string">&quot;code&quot;</span>,<span class="hljs-string">&quot;1234&quot;</span>,<span class="hljs-number">3</span>, TimeUnit.MINUTES);<br>       redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>,<span class="hljs-string">&quot;1&quot;</span>);<br>       redisTemplate.opsForValue().setIfAbsent(<span class="hljs-string">&quot;lock&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>2). 操作哈希类型数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 操作哈希类型的数据</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testHash</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-comment">//hset hget hdel hkeys hvals</span><br>       <span class="hljs-type">HashOperations</span> <span class="hljs-variable">hashOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForHash();<br><br>       hashOperations.put(<span class="hljs-string">&quot;100&quot;</span>,<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;tom&quot;</span>);<br>       hashOperations.put(<span class="hljs-string">&quot;100&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-string">&quot;20&quot;</span>);<br><br>       <span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> (String) hashOperations.get(<span class="hljs-string">&quot;100&quot;</span>, <span class="hljs-string">&quot;name&quot;</span>);<br>       System.out.println(name);<br><br>       <span class="hljs-type">Set</span> <span class="hljs-variable">keys</span> <span class="hljs-operator">=</span> hashOperations.keys(<span class="hljs-string">&quot;100&quot;</span>);<br>       System.out.println(keys);<br><br>       <span class="hljs-type">List</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> hashOperations.values(<span class="hljs-string">&quot;100&quot;</span>);<br>       System.out.println(values);<br><br>       hashOperations.delete(<span class="hljs-string">&quot;100&quot;</span>,<span class="hljs-string">&quot;age&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>3). 操作列表类型数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 操作列表类型的数据</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testList</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-comment">//lpush lrange rpop llen</span><br>       <span class="hljs-type">ListOperations</span> <span class="hljs-variable">listOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForList();<br><br>       listOperations.leftPushAll(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>);<br>       listOperations.leftPush(<span class="hljs-string">&quot;mylist&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>);<br><br>       <span class="hljs-type">List</span> <span class="hljs-variable">mylist</span> <span class="hljs-operator">=</span> listOperations.range(<span class="hljs-string">&quot;mylist&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>       System.out.println(mylist);<br><br>       listOperations.rightPop(<span class="hljs-string">&quot;mylist&quot;</span>);<br><br>       <span class="hljs-type">Long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> listOperations.size(<span class="hljs-string">&quot;mylist&quot;</span>);<br>       System.out.println(size);<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>4). 操作集合类型数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 操作集合类型的数据</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSet</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-comment">//sadd smembers scard sinter sunion srem</span><br>       <span class="hljs-type">SetOperations</span> <span class="hljs-variable">setOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForSet();<br><br>       setOperations.add(<span class="hljs-string">&quot;set1&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-string">&quot;d&quot;</span>);<br>       setOperations.add(<span class="hljs-string">&quot;set2&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;x&quot;</span>,<span class="hljs-string">&quot;y&quot;</span>);<br><br>       <span class="hljs-type">Set</span> <span class="hljs-variable">members</span> <span class="hljs-operator">=</span> setOperations.members(<span class="hljs-string">&quot;set1&quot;</span>);<br>       System.out.println(members);<br><br>       <span class="hljs-type">Long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> setOperations.size(<span class="hljs-string">&quot;set1&quot;</span>);<br>       System.out.println(size);<br><br>       <span class="hljs-type">Set</span> <span class="hljs-variable">intersect</span> <span class="hljs-operator">=</span> setOperations.intersect(<span class="hljs-string">&quot;set1&quot;</span>, <span class="hljs-string">&quot;set2&quot;</span>);<br>       System.out.println(intersect);<br><br>       <span class="hljs-type">Set</span> <span class="hljs-variable">union</span> <span class="hljs-operator">=</span> setOperations.union(<span class="hljs-string">&quot;set1&quot;</span>, <span class="hljs-string">&quot;set2&quot;</span>);<br>       System.out.println(union);<br><br>       setOperations.remove(<span class="hljs-string">&quot;set1&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>5). 操作有序集合类型数据</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 操作有序集合类型的数据</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testZset</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-comment">//zadd zrange zincrby zrem</span><br>       <span class="hljs-type">ZSetOperations</span> <span class="hljs-variable">zSetOperations</span> <span class="hljs-operator">=</span> redisTemplate.opsForZSet();<br><br>       zSetOperations.add(<span class="hljs-string">&quot;zset1&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-number">10</span>);<br>       zSetOperations.add(<span class="hljs-string">&quot;zset1&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-number">12</span>);<br>       zSetOperations.add(<span class="hljs-string">&quot;zset1&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">9</span>);<br><br>       <span class="hljs-type">Set</span> <span class="hljs-variable">zset1</span> <span class="hljs-operator">=</span> zSetOperations.range(<span class="hljs-string">&quot;zset1&quot;</span>, <span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);<br>       System.out.println(zset1);<br><br>       zSetOperations.incrementScore(<span class="hljs-string">&quot;zset1&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>,<span class="hljs-number">10</span>);<br><br>       zSetOperations.remove(<span class="hljs-string">&quot;zset1&quot;</span>,<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><p><strong>6). 通用命令操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 通用命令操作</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testCommon</span><span class="hljs-params">()</span>&#123;<br>       <span class="hljs-comment">//keys exists type del</span><br>       <span class="hljs-type">Set</span> <span class="hljs-variable">keys</span> <span class="hljs-operator">=</span> redisTemplate.keys(<span class="hljs-string">&quot;*&quot;</span>);<br>       System.out.println(keys);<br><br>       <span class="hljs-type">Boolean</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> redisTemplate.hasKey(<span class="hljs-string">&quot;name&quot;</span>);<br>       <span class="hljs-type">Boolean</span> <span class="hljs-variable">set1</span> <span class="hljs-operator">=</span> redisTemplate.hasKey(<span class="hljs-string">&quot;set1&quot;</span>);<br><br>       <span class="hljs-keyword">for</span> (Object key : keys) &#123;<br>           <span class="hljs-type">DataType</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> redisTemplate.type(key);<br>           System.out.println(type.name());<br>       &#125;<br><br>       redisTemplate.delete(<span class="hljs-string">&quot;mylist&quot;</span>);<br>   &#125;<br></code></pre></td></tr></table></figure><h2 id="五、简化方式">五、简化方式</h2><h3 id="5-1-Spring-Cache">5.1 Spring Cache</h3><h4 id="5-1-1-介绍">5.1.1 介绍</h4><p>Spring Cache 是一个框架，实现了基于注解的缓存功能，只需要简单地加一个注解，就能实现缓存功能。</p><p>Spring Cache 提供了一层抽象，底层可以切换不同的缓存实现，例如：</p><ul><li>EHCache</li><li>Caffeine</li><li>Redis(常用)</li></ul><p><strong>起步依赖：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-cache<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>                      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="5-1-2-常用注解">5.1.2 常用注解</h4><p>在SpringCache中提供了很多缓存操作的注解，常见的是以下的几个：</p><table><thead><tr><th><strong>注解</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>@EnableCaching</td><td>开启缓存注解功能，通常加在启动类上</td></tr><tr><td>@Cacheable</td><td>在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中</td></tr><tr><td>@CachePut</td><td>将方法的返回值放到缓存中</td></tr><tr><td>@CacheEvict</td><td>将一条或多条数据从缓存中删除</td></tr></tbody></table><p>在spring boot项目中，使用缓存技术只需在项目中导入相关缓存技术的依赖包，并在启动类上使用@EnableCaching开启缓存支持即可。</p><p>例如，使用Redis作为缓存技术，只需要导入Spring data Redis的maven坐标即可。</p><p><strong>注解的属性</strong></p><p>💡**注意：**cachename：用于制定操作的Redis表</p><p>key：用于制定对于的key，可以用spel语法来书写，进入源码即可查看。</p><p>举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Cacheable(cacheNames = &quot;setmealcache&quot; ,key = &quot;#categoryId&quot;)</span><br><span class="hljs-comment">//在方法执行前先查询缓存中是否有数据，如果有数据，则直接返回缓存数据；如果没有缓存数据，调用方法并将方法返回值放到缓存中</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CacheEvict(cacheNames = &quot;setmealcache&quot;, key = &quot;#setmealDTO.categoryId&quot;)</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CacheEvict(cacheNames = &quot;setmealcache&quot;,allEntries = true)</span><br><span class="hljs-comment">//全部删除</span><br><span class="hljs-comment">//将一条或多条数据从缓存中删除</span><br></code></pre></td></tr></table></figure><h3 id="5-2-具体的实现思路">5.2 具体的实现思路</h3><p>具体的实现思路</p><p>如下:</p><ul><li><p>导入Spring Cache和Redis相关maven坐标</p></li><li><p>在启动类上加入@EnableCaching注解，开启缓存注解功能</p></li><li><p>在接口Controller的l方法上加入@Cacheable、@CachePut、@CacheEvict注解</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>入门知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>入门知识</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL知识总结</title>
    <link href="/pingpinghome/2025/07/24/MySQL%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/pingpinghome/2025/07/24/MySQL%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1>MYSQL</h1><h2 id="1-MYSQL优化问题">1.MYSQL优化问题</h2><h3 id="一、如何定位慢查询？">一、如何定位慢查询？</h3><p><strong>原因：</strong></p><ul><li>聚合查询</li><li>多表查询</li><li>表数据量过大查询</li><li>深度分页查询</li><li>表象：页面加载过慢、接口<strong>压测</strong>响应时间超过1s</li></ul><p><strong>工具</strong>：</p><ul><li><p>调试工具：arthas</p></li><li><p>运维工具：prometheus、<strong>skywalking</strong></p></li><li><p>MYSQL中自带的慢日志查询，需要配置开启和设置慢日志的时间。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">#开启MySQL慢日志查询开关<br>slow_query_log=1<br>#设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志<br>long_query_time=2<br></code></pre></td></tr></table></figure></li></ul><p><strong>回答</strong>：先介绍自己的场景+用的工具+扩展自己知道的其他知识</p><h3 id="二、定位到了语句之后，如何分析呢？">二、定位到了语句之后，如何分析呢？</h3><p><strong>工具/语句：</strong></p><p>在语句面前添加<strong>EXPLAN或者DESC</strong></p><ul><li>possible-keys：当前sql可能用到的索引</li><li><strong>key：实际命中的索引</strong></li><li><strong>key-len：索引占用的大小</strong></li><li><strong>extra：额外的优化建议，是否出现了回表（如果出现using index condition 就表明有优化的空间）</strong></li><li><strong>type</strong>：连接类型，性能由好到坏：NULL、system、<strong>const（主键查询）、eqref（唯一索引或者主键索引查询）、ref（索引查询）、range（范围查询）</strong>、index（全索引查询）、all（全盘扫描）</li><li>如果是index和all就需要优化了。</li></ul><p><strong>回答</strong>：</p><p>面试官：那这个SQL语句执行很慢，如何分析呢？<br>候选人：如果一条sgl执行很慢的话，我们通常会使用mysal自动的执行计划explain来去查看这条sql的执行情况，</p><p>比如在这里面可以通过key和key_len检查是否命中了索引，如果本身已经添加了索引，也可以判断索引是否有失效的情况，</p><p>第二个，可以通过yp字段查看sql是否有进一步的优化空间，是否存在全索引扫描或全盘扫描，</p><p>第三个可以通过extra建议来判断，是否出现了回表的情况，如果出现了，可以尝试添加索引或修改返回字段来修复</p><h3 id="三、什么是索引？">三、什么是索引？</h3><p><strong>回答</strong>（定义+特点）</p><ul><li><strong>索引(index)是帮助MySQL高效获取数据的数据结构（有序）</strong>,其实就是b+树。</li><li>提高数据检索的效率，降低数据库的IO成本（不需要全表扫描）</li><li>通过索引列对数据进行排序（B+树），降低数据排序的成本，降低了CPU的消耗</li><li>mysql默认的innoDB引擎采用的是B+树的数据结构来存储索引</li></ul><h3 id="四、索引的底层（B-树和特点）">四、索引的底层（B+树和特点）</h3><h4 id="1-B树的特点">1.B树的特点</h4><ol><li>B树最多四个key，最多五个字节点，每个节点也是最多四个key。</li><li>B树每一个节点都存储了数据，所以每一次根据索引进行查询的时候都会额外查询多余的数据导致磁盘读写高。</li><li>阶数更多，路径更短</li></ol><h4 id="2-B-树的特点">2.B+树的特点</h4><pre><code class="hljs">1. B+树：磁盘读写代价更低，**非叶子节点只存储指针**，叶子阶存储数据1. B+树便于扫库和区间查询，叶子节点是一个**双向链表**1. 查询效率B+树更加稳定（可以忽略）1. 阶数更多，路径更短</code></pre><ul><li>可能会问B+树和B树的区别</li></ul><p>###五、什么是聚簇索引？</p><p><strong>回答</strong></p><ul><li><p><strong>聚簇索引（聚集索引）</strong>：<strong>数据和索引放到一块，B+树的叶子节点保存整行数据</strong>，有且只有一个</p><p>📖<strong>注意：</strong>(如果有一个主键。那么主键就是索引。如果不存在<strong>主键</strong>，那么<strong>unique</strong>索引为聚集索引，如果都没有，那么innoDB就会自动生成<strong>rowid</strong>作为隐藏索引！)</p></li><li><p><strong>非聚簇索引（二级索引）</strong>：<strong>数据和索引分开存储，B+树的叶子节点保存对应的主键，可以有多个。</strong></p><p>💡**注意：**二级索引一般都是一行数据，而不是聚簇索引一样是一个数据。</p></li><li><p>**回表查询：**举个例子方便理解，比如我们查询</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where name =&quot;猪博客&quot;;<br></code></pre></td></tr></table></figure><p>此时先走二级索引查询到聚集索引，之后根据聚集索引查找到我们需要的数据。</p><p>📖笔记：通过二级索引查找到主键值，到聚集索引中查找整行数据，这个过程就是回表查询。</p></li></ul><h3 id="七、覆盖索引">七、覆盖索引</h3><p><strong>回答</strong></p><p><strong>覆盖索引是指查询使用了索引，返回的列，必须在 索引中全部能够找到</strong></p><p>说人话就是，一次查询就可以直接找出来，不需要回表查询。</p><ul><li>使用id查询（主键），直接走聚集索引查询，一次索引扫描，直接返回整行数据，效率高</li><li>如果返回的列中没有所要查询的字段，有可能会触发回表查询，所以尽量避免用select*</li></ul><h3 id="八、超大分页如何处理">八、超大分页如何处理</h3><p><strong>定义</strong></p><p>在数据量比较大时，如果进行limit分页查询，在查询时，越往后，效率越低</p><p><strong>回答</strong></p><p>可以用<strong>覆盖索引+子查询来解决</strong>。</p><p><img src="https://qjw-00.oss-cn-guangzhou.aliyuncs.com/%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8/%E5%88%86%E9%A1%B5%E6%9F%A5%E8%AF%A2.jpg" alt=""></p><blockquote><p><strong>面试官：知道什么叫覆盖索引嘛？</strong><br>候选人：嗯~，清楚的<br>覆盖索引是指select查询语句使用了索引，在返回的列，必须在索引中全部能够找到，如果我们使用id查询，它会直接走聚集索引查询，一次索引扫描，直接返回数据，性能高。<br>如果按照二级索引查询数据的时候，返回的列中没有创建索引，有可能会触发回表查询，尽量避免使用select*,尽量在返回的列中都包含添加索引的字段<br><strong>面试官：MYSQL超大分页怎么处理？</strong><br>候选人：嗯，超大分页一般都是在数据量比较大时，我们使用了Iit分页查询，并且需要对数据进行<br>排序，这个时候效率就很低，我们可以采用覆盖索引和子查询来解决<br>先分页查询数据的id字段，确定了id之后，再用子查询来过滤，只查询这个id列表中的数据就可以了<br>因为查询i的时候，走的覆盖索引，所以效率可以提升很多</p></blockquote><h3 id="九、索引创建的原则（1256要提及）">九、索引创建的原则（1256要提及）</h3><ol><li><strong>数据量较大，且查询频繁的表（单表超过10万数据）</strong></li><li><strong>常作为查询条件、排序、分组（where、order by 、 group by）操作</strong></li><li>尽量选择<strong>区分度高</strong>的列作为索引，区分度越高，效率越高（尽量建立唯一索引！！）</li><li>如果是字符串类型的字段，可以利用<strong>字符串的特点建立前缀索引</strong></li><li><strong>尽量使用联合索引</strong>，查询时很多时候联合索引可以覆盖索引，节省存储空间，避免回表。</li><li><strong>控制索引数量</strong></li><li>如果索引列不能存NULL要加<strong>not null</strong>！！</li></ol><h3 id="十、索引失效（5）">十、索引失效（5）</h3><p><strong>判断标准</strong></p><ul><li>违反了最左前缀法则</li><li>范围查询右边的列是无法使用范围索引的</li><li>不要再索引列上进行运算操作，否则索引失效</li><li>字符串不加单引号</li><li>以like开头的模糊索引会导致失效（%在前面的都会失效）</li></ul><p><strong>工具</strong></p><p>执行计划explain</p><h3 id="十一、sql的优化经验">十一、sql的优化经验</h3><ul><li>表的设计优化</li><li>索引优化  （<strong>九+十</strong>）</li><li>sql语句的优化</li><li>主从复制，读写分离</li><li>分库分表</li></ul><h4 id="表的设计优化（参考阿里开发手册）">表的设计优化（参考阿里开发手册）</h4><ol><li>设置合适的数值，根据实际情况选择（tinyint int bigint）</li><li>char和varchar，char定长效率高，var可变长度，效率低一些</li></ol><h4 id="sql语句的优化">sql语句的优化</h4><ol><li><strong>select语句避免 （*） 这种查找</strong></li><li>sql避免索引失效</li><li><strong>union all</strong> 代替 union ，union会多一次过滤，效率低</li><li>避免where子句中对字段进行表达式操作</li><li>join优化，能用<strong>innerjoin</strong>就不用左右join，如果要用，一定要以小表为驱动，内连接会对两个表进行优化，优先把小表放外边，大表放里边，左右join不会重新排序</li></ol><h2 id="2-事务">2.事务</h2><h3 id="2-1事务介绍">2.1事务介绍</h3><ul><li>事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，要么一起成功，要么一起失败。</li><li>最好的例子就是银行转账。</li><li>特性：ACID<ul><li>原子性：要么一起成功，要么一起失败。</li><li>一致性：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性：数据库提供隔离机制，保证独立运行。</li><li>持久性：一旦回滚或者提交，就是永久的。</li></ul></li></ul><h3 id="2-2事务的问题">2.2事务的问题</h3><ol><li><p>并发事务的问题</p><table><thead><tr><th>问题</th><th>描述</th></tr></thead><tbody><tr><td>脏读</td><td>一个事务读到另外一个事务还没有提交的数据</td></tr><tr><td>不可重复读</td><td>两次读取的数据不同</td></tr><tr><td>幻读</td><td>查询不到，插入的时候又发现已经存在</td></tr></tbody></table></li><li><p>解决</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>未提交读</td><td>✔️</td><td>✔️</td><td>✔️</td></tr><tr><td>读已提交</td><td>❌</td><td>✔️</td><td>✔️</td></tr><tr><td>可重复读（默认）</td><td>❌</td><td>❌</td><td>✔️</td></tr><tr><td>串行化</td><td>❌</td><td>❌</td><td>❌</td></tr></tbody></table><p>💡注意：事务隔离级别越高，数据越安全，但是性能越低。​</p></li><li><p>undo log 和redo log的区别</p><ul><li><p>缓冲池（bufferpool）：主内存中的一个区域，里面可以缓存磁盘上经常操作的真实数据，在执行增删改查操作时，先操作缓冲池中的数据（若缓冲池没有数据，则从磁盘加载并缓存），以一定频率刷新到磁盘，从而减少磁盘IO，加快处理速度</p></li><li><p>数据页（page）：是InnoDB存储引擎磁盘管理的最小单元，每个页的大小默认为16KB。页中存储的是行数据</p></li></ul><p>**区别：**对于redo log （重做日志），记录的是事务提交时数据页的物理修改，用来实现事务的持久性。</p><p>该日志文件由两部分组成：重做日志缓冲（redologbuffer）以及重做日志文件（redolog file），前者是在内存中，后者在磁盘中。</p><p>当事务提交之后会把所有修改信息都存到该日志文件中，用于在刷新脏页到磁盘，发生错误时，进行数据恢复使用。</p><p>**区别：**对于undo log（回滚日志），用于记录数据被修改前的信息，作用包含两个：提供回滚和MVCC(多版本并发控制)。undolog和redolog记录物理日志不一样，它是逻辑日志。</p></li></ol><p>​可以认为当delete一条记录时，undolog中会记录一条对应的insert记录，反之亦然，当update一条记录时，它记录一条对应相反的update记录。</p><p>​当执行rollback时，就可以从undolog中的逻辑记录读取到相应的内容并进行回滚。</p><p>总结：</p><ul><li>redolog：记录的是数据页的物理变化，服务宕机可用来同步数据</li><li>undolog：记录的是逻辑日志，当事务回滚时，通过逆操作恢复原来的数据</li><li>redolog保证了事务的<strong>持久性</strong>，undolog保证了事务的<strong>原子性和一致性</strong></li></ul><h3 id="2-3事务的隔离性、">2.3事务的隔离性、</h3><ol start="5"><li>事务的隔离性怎么解决？</li></ol><ul><li>排他锁</li><li>mvcc多版本并发控制</li></ul><p>解释一下mvcc！</p><p>MVCC</p><p>定义：MySQL中的多版本并发控制。指维护一个数据的多个版本，使得读写操作没有冲突</p><ul><li>隐藏字段</li></ul><p>​①trx_id（事务id)，记录每一次操作的事务id，是自增的</p><p>​②roll_pointer(回滚指针)，指向上一个版本的事务版本记录地址</p><ul><li>undo log</li></ul><p>​①回滚日志，存储老版本数据</p><p>​②版本链：多个事务并行操作某一行记录，记录不同事务修改数据的版本，通过roll_pointer指针形成一个链表</p><ul><li>readView解决的是一个事务查询选择版本的问题<ul><li>根据readView的匹配规则和当前的一些事务id判断该访问那个版本的数据</li><li>不同的隔离级别快照读是不一样的，最终的访问的结果不一样<ul><li>RC：每一次执行快照读时生成ReadView</li><li>RR：仅在事务中第一次执行快照读时生成ReadView，后续复用</li></ul></li></ul></li></ul><h2 id="3其他问题">3其他问题</h2><h3 id="3-1主从同步">3.1主从同步</h3><ul><li>二进制日志（BINLOG）记录了所有的DDL（数据定义语言）语句和DML（数据操纵语言）语句，但不包括数据查询（SELECT、SHOW）语句。</li></ul><p>MySQL主从复制的核心就是二进制日志binlog（DDL（数据定义语言）语句和DML（数据操纵语言）语句）</p><p>①主库在事务提交时，会把数据变更记录在二进制日志文件Binlog中。</p><p>②从库读取主库的二进制日志文件Binlog，写入到从库的中继日志RelayLog。</p><p>③从库重做中继日志中的事件，将改变反映它自己的数据</p><h3 id="3-2分库分表">3.2分库分表</h3><p>主从同步是用来分担访问压力的，主写，从读。</p><p>分库分表的时机：</p><ul><li><p>单表的数据量达到1000W或者20G以后</p></li><li><p>数据库的用户量和数据量到了一定数量的时候，优化已经解决不了性能的问题了。</p></li><li><p>io瓶颈、cpu瓶颈</p></li></ul><h4 id="1-拆分策略">1.拆分策略</h4><p><strong>垂直</strong></p><p>垂直分库：以表为依据，根据业务将不同的表拆分到不同的库中。（将库中不同业务，如登录和商品，拆分到不同的库中分别存储）</p><p>垂直分表：以字段为依据，根据字段属性将不同的字段拆分到不同表中。（距离，商品的详细信息和商品id拆分）</p><ul><li>冷热数据分离</li><li>减少io过渡争抢、两表互不影响。</li></ul><p><strong>水平</strong>（例如id%3来进行表格的访问）</p><p>水平分库：将一个库的数据拆分到多个库中。（<strong>海量存储的问题</strong>）</p><ul><li>解决单库大数量，高并发的性能瓶颈问题</li><li>提高了系统的稳定性和可用性</li></ul><p>水平分表：将一个表的数据拆分到多个表中（可以在同一个库内）</p><h4 id="2-新的问题">2.新的问题</h4><p>分库分表会出现很多新的问题，比如多个表的id可能自增重复，多个表可能事务提交不一致，多个表的分页排序、跨节点关联查询等。<br><strong>中间件来优化</strong>：</p><ul><li>sharding-sogere</li><li>mycat</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习过程</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>redis知识总结</title>
    <link href="/pingpinghome/2025/07/23/redis%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"/>
    <url>/pingpinghome/2025/07/23/redis%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1>redis</h1><h2 id="一、redis三兄弟">一、redis三兄弟</h2><ul><li>穿透</li><li>击穿</li><li>雪崩</li></ul><h3 id="穿透"><strong>穿透</strong></h3><p>穿透是指，查询一个不存在的数据，mysql查询不到，也不会写入缓存，导致每一次请求都会查询数据库，大量的请求导致宕机。</p><p>原因是：①：可能是路径被人恶意攻击，redis没有相对应的数据，所以去查询数据库，但大量的查询操作执行的时候，数据库就会被压垮。</p><p>解决：</p><ul><li>布隆过滤器</li><li>null返回</li></ul><p><img src="https://qjw-00.oss-cn-guangzhou.aliyuncs.com/%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.jpg" alt=""></p><h3 id="击穿"><strong>击穿</strong></h3><p>击穿是指，当某一个key过期的时候，大量请求无法在redis中查询，转而去数据库查询，一时间大量的查询导致数据库压力过大。</p><p>原因是：①：key过期了</p><p>解决：</p><ul><li>加锁，分布式锁。<strong>互斥锁</strong>（保证强一致性、性能差一点）</li><li>逻辑过期（高可用、性能优）</li></ul><p><img src="https://qjw-00.oss-cn-guangzhou.aliyuncs.com/%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8/%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF.jpg" alt=""></p><h3 id="雪崩"><strong>雪崩</strong></h3><p>雪崩是指在同一时间段大量的缓存key同时失效，或者redis宕机，导致大量的请求到数据库，带来巨大的压力。</p><p>原因：key失效，redis宕机</p><p>解决：</p><ul><li>给不同的key设置TTL随机过期值</li><li>利用redis集群提高服务的可用性       <strong>哨兵模式，集群模式</strong></li><li>给缓存业务添加降级限流策略            <strong>ngxin或spring cloud gateway</strong></li><li>多级缓存                                               <strong>guava或者caffeine</strong></li></ul><h2 id="二、双写一致性（redis和数据库）">二、双写一致性（redis和数据库）</h2><p><strong>这种问题要结合业务进行回答，切记切记</strong></p><h3 id="双写一致性">双写一致性</h3><p>当修改了数据库的数据时，需要同时去更新缓存的数据，缓存要和数据库的数据保持一致</p><p>读操作：读取命中直接返回，不命中查询数据库，写入缓存，再返回。</p><p>写操作：<strong>延迟双删</strong></p><p>我们要延迟双删（删除缓存→删除数据库→删除缓存），原因是数据库双写不一致的问题。</p><h3 id="需要强一致的话"><strong>需要强一致的话</strong></h3><p>分布式锁：</p><p><strong>在读的时候添加共享锁，再写的时候添加排它锁。</strong></p><p>共享锁：其他线程也可以读</p><p>排它锁：其他线程无法进行读写操作</p><p><strong>特点</strong>：强一致性，性能低</p><h3 id="不需要强一致性的话（最终一致性）"><strong>不需要强一致性的话（最终一致性）</strong></h3><p><strong>异步通知：MQ和canal</strong></p><p>cannal：对代码无侵入，伪装mysql的一个从节点</p><ul><li>主要是监听binlog文件，当数据库改变的时候，就会通知缓存变更情况。进行数据更新。</li></ul><p>MQ：主要依靠 MQ的可靠性</p><ul><li>修改数据的时候，就会有消息通知MQ，然后MQ监听缓存进行数据更新。</li></ul><h2 id="三、持久化">三、持久化</h2><h3 id="RDB">RDB</h3><p>RDB：也就是redis的快照，简单来说就是把内存中的所有数据写入到磁盘中。当redis故障重启的时候，从磁盘读取快照，恢复数据</p><p>保存命令：</p><ul><li><p>save：主进程执行，</p></li><li><p>bgsave:子程序进行运行，避免主程序收到影响（fork），子进程<strong>共享</strong>主进程的内存数据。原因是页表相同映射。</p><p>页表：记录虚拟地址与物理地址的映射关系。</p></li><li></li></ul><h3 id="AOF">AOF</h3><p>AOF全称为append only File（追加文件）。redis处理的每一个写命令都会记录在AOF文件，可以看作是命令日志文件。</p><p>默认是关闭的，redis.conf来开启，也可以通过文件来修改频率。</p><ul><li>always：同步刷盘（可靠性高，几乎不丢失数据，但性能影响大）</li><li>everysec：每秒刷盘（适中，最多丢失一秒的数据）</li><li>no：操作系统控制（性能最高，可靠性差，可能丢失大量数据。</li></ul><p>AOF的文件比RDB大，会记录一个key的多次操作但<strong>只有最后一次操作有效</strong>，通过执行bgrewriteaof来进行文件重写，用最少的命令达到一样的效果。</p><p>redis在触发阈值时会自动去重写AOF文件。阈值同样可以进行设置。</p><h3 id="两者的区别">两者的区别</h3><p>主要优缺点，RDB文件小，二进制，速度快，但是有丢失的风险。AOF文件大、速度慢，但是风险小。</p><p><img src="https://qjw-00.oss-cn-guangzhou.aliyuncs.com/%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8/RDB%E5%92%8CAOF%E7%9A%84%E5%8C%BA%E5%88%AB.jpg" alt=""></p><h2 id="四、数据过期策略">四、数据过期策略</h2><p>但key过期的时候，redis会立刻删除吗？</p><p>并不会！删除策略有两种，惰性删除和定时删除。</p><h3 id="1-惰性删除">1. 惰性删除</h3><p>当我们设置了过期时间之后，我们就不去管它了，<strong>只有用到这个key的时候才会去判断是否过期，如果过期就删除</strong>。</p><ul><li>优点：对cpu很友好，只有使用的时候才会去调用过期检查，节省资源</li><li>缺点：对内存很不友好，若是不调用，它就一直呆在内存之中，浪费内存。</li></ul><h3 id="2-定时删除">2. 定时删除</h3><p>每隔一段时间，就对一些key进行检查，删除里面的过期key（从一定量的数据库中，取出一定数量的<strong>随机</strong>key进行检查，并删除过期的key）</p><h4 id="2-1-SLOW">2.1 SLOW</h4><p>慢模式，定时删除，每次删除的间隔为10hz，也就是一秒十次（100ms/次），每次不超过25ms，可以通过配置文件中的HZ选项进行设置，来调整</p><h4 id="2-2-FAST">2.2 FAST</h4><p>快模式，执行的频率不固定，但执行间隔不低于2ms，每次耗时1ms。</p><h4 id="2-3-优缺点">2.3 优缺点</h4><p>有点：通过限制频率来减少对于cpu的影响，同时也可以释放内存</p><p>缺点：难以确定删除操作的频率和时长。</p><h2 id="五、数据淘汰策略">五、数据淘汰策略</h2><p>假如缓存过多，内存满了怎么办？</p><h3 id="数据淘汰策略：8种">数据淘汰策略：8种</h3><ul><li><p>noeviction：默认，表示当内存满的时候不再添加新的key</p></li><li><p>volatile-ttl：对设置了ttl的key进行判断，越小，就越先被淘汰</p></li><li><p>allkeys-random：对所有的key进行随机淘汰</p></li><li><p>volatile-random：对设置了ttl的key进行随机判断</p></li><li><p>allkeys-lru：对所有的key执行lru策略，最后一次访问越久越先淘汰</p></li><li><p>volatile-lru：对设置了ttl的key执行lru策略。</p></li><li><p>allkeys-lfu：对所有的key执行lfu策略，访问次数越少的，越先淘汰</p></li><li><p>volatile-lfu：对设置了ttl的key执行lfu策略，访问次数越少的，越先淘汰</p></li></ul><p><strong>重点在于，要记住lru策略和lfu策略。lru（recently最少最近）lfu（frequently熟悉的最少评率）</strong></p><p>对于使用什么策略的建议。</p><ul><li>优先使用<strong>allkeys-lru</strong>来进行淘汰，如果业务有明显的冷热数据区分，推荐这个方法</li><li>如果业务中的数据没有冷热区分，访问的频率也差不多，推荐用<strong>allkeys-random</strong></li><li>如果业务中有置顶的需求，那就可以用<strong>volatile-lru</strong>，对置顶数据不进行ttl的设置，只会淘汰其他数据。</li><li>如果时短时高频的需求，用<strong>lfu</strong>的两个策略。</li></ul><h3 id="问题：">问题：</h3><p>1.数据库有1000万的数据，redis只能存20万，如何保证redis中都是热点数据呢？</p><p>答：用allkeys-lru来进行淘汰，删除最长时间访问的数据，保留热数据。</p><p>2.redis的内存用完了会发生什么？</p><p>答：数据淘汰，看你是什么设置，如果是默认norviction会直接报错。</p><h2 id="六、分布式锁">六、分布式锁</h2><h3 id="1-导读">1. 导读</h3><p>例子，抢卷服务，会员兑换码等</p><p>如果有最后一张卷，结果是两个进程查询到了卷，先后获得了优惠卷，最后会导致票数超限。</p><p>为了解决这个问题，我们可以加锁。</p><p>如果是一台服务器中，我们可以直接用synchronized（this）{}来进行锁的限制，可以解决这个问题。</p><p>** 但是！！！**在实际开发中，我们的程序时部署在多个服务器中的，这个时候synchronized锁就只能在一台服务器中使用，无法防止上述超限的问题发生。</p><p>这个时候就要用到分布式锁。</p><p>原理：</p><p>分布式锁的原理很简单，那就是拿一个中间人作为锁的管理，由它来监控锁。这里用的是redis。当8080服务器获取锁成功后，就给分布式锁做个标记，告诉分布式锁8080中的线程1已经获取锁了。</p><p>此后，其他服务器8081想要获得锁，分布式锁就会拒绝这个请求，加锁失败，程序进入阻塞状态。</p><h3 id="2-redission实现">2. redission实现</h3><h4 id="2-1-redis实现的分布式锁">2.1 redis实现的分布式锁</h4><p>对于redis实现分布式锁来说，用的是setNX来进行设置</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cmd">//获得锁<br><span class="hljs-built_in">SET</span> lock value NX EX <span class="hljs-number">10</span><br>//释放锁<br><span class="hljs-built_in">DEL</span> key<br></code></pre></td></tr></table></figure><p>EX来设置它的过期时间，那么就有新的问题，这个过期时间多少合适？</p><p>解决办法有两个：①预估服务的时间后判断 ②看门狗自动续期</p><p>显然是第二个啊，看门狗机制来延长服务的时间，防止服务过期。一般这个续期的时间是服务设置时间的1/3。看门狗需要手动去通知停止。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">redisLock</span><span class="hljs-params">()</span><span class="hljs-keyword">throws</span> InterruptedException&#123;<br>    <span class="hljs-comment">//获取锁（重入锁），执行锁的名称</span><br>    <span class="hljs-type">RLock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> redissonClient.getLock( s:<span class="hljs-string">&quot;heimalock&quot;</span>);<br>    <span class="hljs-comment">//尝试获取锁，参数分别是：获取锁的最大等待时间（期间会重试），锁自动释放时间，时间单位</span><br>    <span class="hljs-comment">//boolean isLock = lock.tryLock(10,30，TimeUnit.SEC0NDS);</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">isLock</span> <span class="hljs-operator">=</span> lock.tryLock(time:<span class="hljs-number">10</span>，TimeUnit.SEC0NDS);<br>    <span class="hljs-comment">//判断是否获取成功加锁、设置过期时间等操作都是基于lua脚本完成</span><br>    <span class="hljs-keyword">if</span> （isLock）&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            System.out.println（<span class="hljs-string">&quot;执行业务&quot;</span>）;<br>        &#125;<br>        <span class="hljs-keyword">finally</span><br>    &#123;<br>            <span class="hljs-comment">//释放锁</span><br>            lock.unlock();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>💡**注意:**如果手动设置了过期时间，那么看门狗机制就会失效，redis认为你可以自己管理时间。默认30s关闭时间。</p><p>💡**注意:**在底层中是用SETNX和lua脚本实现的。</p><h4 id="2-2-redisson实现的分布式锁">2.2 redisson实现的分布式锁</h4><p>💡：redisson中的分布式锁是可以重入的，而redis不可以。</p><p>重入锁是一种累计的重入次数值。</p><p>其中key是自己定义的唯一标识，而value是重入的个数。</p><p>分布式锁如何解决一致性的问题呢？</p><p>在服务写入数据的时候，redis宕机了，导致数据无法正常操作，这是后按照redis的机制，挑选从节点成为主节点。此时，就会出现两个线程有同一个锁。</p><p>为了解决这个问题，redis提供了红锁。（N/2  +1 ）在多个实例上面加锁，从而避免这个问题。（很少用，性能很差，而且很复杂，很繁琐。）如果非要保证数据的一致性，可以使用zookeeper来实现。</p><h2 id="七、redis集群方案">七、redis集群方案</h2><h3 id="分类">分类</h3><ul><li>主从复制</li><li>哨兵模式</li><li>Redis分片集群</li></ul><h3 id="主从复制">主从复制</h3><p><strong>介绍一下主从复制？</strong></p><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，可以搭建主从集群，实现<strong>读写分离。<strong>一般都是</strong>一主多从</strong>，<strong>主节点负责写数据</strong>，<strong>从节点负责读数据</strong>，主节点写入数据之后，需要把数据同步到从节点中。</p><p><img src="https://qjw-00.oss-cn-guangzhou.aliyuncs.com/%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8/%E9%9B%86%E7%BE%A4.jpg" alt=""></p><p>主从全量同步。直接看图吧。</p><ul><li><strong>全量同步：<strong>slaver发出请求，master判断是否为同一个</strong>集群id</strong>（是否第一次接收），如果是，就返回版本信息，并foke一个程序进行RDB生成和传递回去。slaver接收到版本后保存，随后清空数据用RDB加载数据。同时在执行上面过程中，如果数据有更行，master节点会发送执行期间的日志文件给slaver，slaver执行之后保持同步。</li><li><strong>增量同步：<strong>如果是第二次的话，这个过程有点区别。slaver发出请求，master判断是否为同一个</strong>集群id</strong>，发现不是。master节点会发送执行期间的日志文件给slaver，slaver执行之后保持同步。</li><li>💡 笔记:需要注意的是，判断是不是第一次的一句是看集群id，判断日志文件的多少用的是偏移量。</li></ul><p><img src="https://qjw-00.oss-cn-guangzhou.aliyuncs.com/%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8/%E4%B8%BB%E4%BB%8E%E5%85%A8%E9%87%8F%E5%90%8C%E6%AD%A5.jpg" alt=""></p><h3 id="哨兵模式">哨兵模式</h3><p>哨兵的构成：</p><ul><li><p>哨兵也是<strong>集群</strong>的，至少三台</p><ul><li><strong>监控</strong>：哨兵sentinel会不断的检查master和slave是否按照预期工作</li><li><strong>自动故障恢复</strong>：如果master故障，sentinel会将一个slave升级为master，当故障恢复后，也以新的master为主。</li><li><strong>通知</strong>：sentinel充当redis客户端的服务来发现源，当集群发生故障转移时，会将最新消息推送给redis客户端（说人话就是不需要对代码进行修改，故障的时候会自动分配master）</li></ul></li><li><p><strong>服务状态监控</strong></p><p>sentinel基于<strong>心跳机制</strong>监测服务状态，每隔<strong>1s</strong>向集群的每个实例发生ping命令：</p><ul><li>主观下线：一台发现实例未在规定的时间响应</li><li>客观下线：超过指定数量（quorum）（一般是哨兵的一半以上（n/2+1））都认为主观下线，那么就认为是客观下线。</li></ul><p>当判断下线之后，哨兵就会开始挑选新的master</p><ul><li>判断主从节点断开时间的长短（越短越好），超过指定时间排除</li><li>判断优先级（slave-priority），越小越高</li><li><strong>如果优先级一致，判断slave节点的offset值，越大优先级越高（也就是数据越多越好）</strong></li><li>最后判断id运行的大小，越小优先级越高（这个无所谓）</li></ul></li><li><p><strong>脑裂问题</strong></p><p>所谓的脑裂，就是当客户端断网之后（处于不同的网络分区），哨兵ping不通master，以为master挂了，所以把slave升级为master。（此时原来的master依旧可以写），等网络恢复之后，原来的master就被强制降级为slave。导致<strong>数据可能丢失</strong>。</p><p><strong>解决办法</strong>：</p><ul><li>min-replicas-write 1 表示<strong>最少的salve节点</strong>为1个。</li><li>min-replicas-max-lag 5 表示<strong>数据复制和同步的延迟</strong>不超过5秒。</li><li>这样设置之后，就导致<strong>旧的master</strong>写入请求的时候因为不符合上述的两个条件<strong>被拒绝</strong>，写入请求就会到<strong>新的master上，从而解决脑裂的问题</strong></li></ul></li></ul><h3 id="分片集群">分片集群</h3><p>主从和哨兵可以解决高可用、高并发读的问题。</p><p>但是依然有两个问题没有解决：</p><ul><li><strong>海量数据存储问题</strong></li><li><strong>高并发写的问题</strong></li></ul><p>使用分片集群可以解决上述问题，<strong>分片集群特征</strong>（作用）：</p><ul><li>集群中有多个master,每个masterf保存不同数据</li><li>每个master都可以有多个slave节点</li><li>master之间通过ping监测彼此健康状态（代替哨兵）</li><li>客户端请求可以访问集群<strong>任意节点</strong>，<strong>最终都会被转发到正确节点</strong></li></ul><p><strong>Redis分片集群中数据是怎么存储和读取的？</strong></p><p>Redis分片集群引入了哈希槽的概念，Redis集群有<strong>16384</strong>个哈希槽，每个key通过CRC16校验后对16384取模来<br>决定放置哪个槽，集群的每个节点负责一部分hash槽。（<strong>有有效值看有效值，没有看key哈希值与16384取模</strong>）</p><h3 id="redis为什么快">redis为什么快</h3><ul><li><p><strong>因为它是单线程，避免不必要的线程切换和竞争条件，同时不用考虑线程安全问题</strong></p></li><li><p><strong>存内存操作，执行快</strong></p></li><li><p><strong>IO多路复用，非阻塞IO</strong>（例如bgsave和bgrewriteaof都是后台执行）</p><ul><li><p>内核空间和外核空间</p><ul><li>内核空间：几乎具备所有权限的系统空间</li><li>外核空间：用户的操作空间</li><li>内核空间是中转站：外核空间-内核空间-硬件</li></ul><p><img src="https://qjw-00.oss-cn-guangzhou.aliyuncs.com/%E4%B8%AA%E4%BA%BA%E4%BD%BF%E7%94%A8%E5%AD%98%E5%82%A8/%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4.jpg" alt=""></p></li><li><p>阻塞IO</p><p>在等待数据和准备数据的过程中是阻塞的，在拷贝数据的过程中也是阻塞的。</p></li><li><p>非阻塞IO</p><p>在等待数据和准备数据的过程中不是阻塞的，后面一样。但cpu消耗大</p></li><li><p><strong>IO多路复用</strong></p><p><strong>单个线程可以一次性监听多个socket</strong>，虽然两个都是阻塞，但是一旦某个socket可读就会通知，避免无效等待。<strong>节省cpu</strong>，底层用epoll实现，在通知socket就绪的同时也通知是哪个socket。提升了性能</p><p>io多路复用的实现方式</p><ul><li><p>select</p></li><li><p>poll</p></li><li><p>epoll</p><p>前两个都是通知系统但没有携带socket，需要一个个去找，epoll则会在通知系统就绪的时候提供socket的信息</p></li></ul></li></ul></li><li><p>Redis网络模型</p><p>就是使用l/O多路复用结合事件的处理器来应对多个Socketi请求</p><blockquote><p><strong>连接应答处理器</strong></p><p><strong>命令回复处理器</strong>，在Redis6.0之后，为了提升更好的性能，使用了多线程来处理回复事件<br><strong>命令请求处理器</strong>，在Rdis6.0之后，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程</p></blockquote></li></ul><p><a href="https://heuqqdmbyk.feishu.cn/wiki/V45ewmbN6i8nm8kNl01c7qClnTc">Redis篇 - 飞书云文档</a></p>]]></content>
    
    
    <categories>
      
      <category>面试知识</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习过程</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo部署vscode</title>
    <link href="/pingpinghome/2025/07/21/hexo%E9%83%A8%E7%BD%B2vscode/"/>
    <url>/pingpinghome/2025/07/21/hexo%E9%83%A8%E7%BD%B2vscode/</url>
    
    <content type="html"><![CDATA[<h1>hexo部署vscode</h1><blockquote><p>今天，好朋友想要基于hexo来搭建一个博客，但是在部署的过程中出现了问题，一时间我也不知道如何解决，所以我就把我部署的经验和过程写下来，方便之后进行查阅和修改。</p></blockquote><h2 id="1-准备">1.准备</h2><h3 id="1-1前提">1.1前提</h3><p>当前PC环境中有Node和Git。版本可以参考Hexo文档。<br>文章中出现的yourusername为Github用户名，your-repo为仓库名。</p><h3 id="1-2使用的软件">1.2使用的软件</h3><ul><li><a href="https://hexo.io/zh-cn/">Hexo</a></li><li><a href="https://git-scm.com/">Git</a></li><li><a href="https://github.com/">GitHub</a></li><li><a href="https://code.visualstudio.com/">VSCode</a></li><li><a href="https://markdown.com.cn/">Markdown</a></li></ul><h3 id="1-3注意事项">1.3注意事项</h3><ul><li>确保你全程都是管理员权限</li><li>确保你可以链接到GitHub</li><li>确保你的GitHub用户名、邮箱、GitHub Pages的域名已经设置好</li><li>上面的软件下载好</li></ul><h2 id="2-Hexo安装">2.Hexo安装</h2><h3 id="2-1-安装Hexo">2.1 安装Hexo</h3><p>安装脚手架，初始化hexo，这会新建blog文件夹，进入后安装依赖。<br>打开vscode，在终端输入以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br>hexo init blog（这一句可以省略blog）<br><span class="hljs-built_in">cd</span> blog（这一句可以省略）<br>npm install<br></code></pre></td></tr></table></figure><h3 id="2-2-初始化仓库">2.2 初始化仓库</h3><p>可以选择利用VSCode等软件直接对项目开源到github仓库。<br>也可以手动去github创建一个空仓库，然后手动在命令行中推送。<br>我是直接点击vscode最上面的输入框，直接推送到新仓库自动创建了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">git init<br>git remote add origin https://github.com/yourusername/your-repo.git<br>git add .<br>git commit -m <span class="hljs-string">&quot;Initial commit&quot;</span><br>git push -u origin main<br></code></pre></td></tr></table></figure><h3 id="2-3-创建token">2.3 创建token</h3><p>在个人设置中新增一个Personal access tokens。至少要包含repo权限，然后记住token。<br>这个token是给Github Action用的，Github Action会把Hexo编译部署到gh-pages分支。<br>具体可以查看网上的教程，这里我直接用人话</p><p>点击github的头像，点击settings，找到开发者设置，点击个人令牌访问，点击令牌（经典），然后点击生成新令牌，选择经典就好。保存好你的token，时间自己设置。</p><p>获取token之后，返回hexo的仓库，点击setting，找到secrets，点击Secrets and variables，点击action，点击new repository secret，输入token的名字（这个和后面保持一致），输入token的值，然后点击add secret。</p><h3 id="2-4-修改-config-yml">2.4 修改_config.yml</h3><p>在_config.yml中修改deploy字段。指示Hexo在deploy时的推送地址。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github.com/yourusername/your-repo.git</span><br>  <span class="hljs-attr">branch:</span> <span class="hljs-string">gh-pages</span><br></code></pre></td></tr></table></figure><h2 id="3-配置Github-Action工作流-如果不需要工作流，可以略过">3 配置Github Action工作流(如果不需要工作流，可以略过)</h2><p>在.github文件夹下新增workflows文件夹，然后新增deploy.yml文件，内容如下。</p><p>里面有个node-version要和你本地的node一致。</p><p>步骤大致意思就是使用ubuntu-latest作为基础环境，然后安装各种依赖，随后hexo generate生成博客网站静态文件夹，<br>把这个文件夹推送到同一仓库的gh-pages分支。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span>  <span class="hljs-comment"># 当推送到 main 分支时触发</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">repository</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">submodules:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 禁用子模块检查</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">Node.js</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v2</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">&#x27;18&#x27;</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Dependencies</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">Hexo</span> <span class="hljs-string">Git</span> <span class="hljs-string">Deployer</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          npm install hexo-deployer-git --save</span><br><span class="hljs-string">          npm install hexo-cli -g</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Clean</span> <span class="hljs-string">and</span> <span class="hljs-string">Generate</span> <span class="hljs-string">Static</span> <span class="hljs-string">Files</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          hexo clean</span><br><span class="hljs-string">          hexo generate</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Configure</span> <span class="hljs-string">Git</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          git config --global user.name &#x27;github-actions[bot]&#x27;</span><br><span class="hljs-string">          git config --global user.email &#x27;github-actions[bot]@users.noreply.github.com&#x27;</span><br><span class="hljs-string"></span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">to</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-attr">GH_TOKEN:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GH_TOKEN</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          cd public/</span><br><span class="hljs-string">          git init</span><br><span class="hljs-string">          git add -A</span><br><span class="hljs-string">          git commit -m &quot;Create by workflows&quot;</span><br><span class="hljs-string">          git remote add origin https://$&#123;&#123; secrets.GH_TOKEN &#125;&#125;@github.com/yourusername/your-repo.git</span><br><span class="hljs-string">          git push origin HEAD:gh-pages -f</span><br></code></pre></td></tr></table></figure><h3 id="3-1-推送验证（如果不需要工作流，可以略过）">3.1 推送验证（如果不需要工作流，可以略过）</h3><p>把刚才更新的所有文件都推送一遍，github就会触发工作流，然后去网站看工作流运转的如何。<br>等一切运转完毕，就会发现仓库多出一个gh-pages分支。</p><h3 id="3-2-配置Github-Pages">3.2 配置Github Pages</h3><p>在仓库settings中配置page来源为gh-pages分支即可。等待网站部署完毕，就可以看了。网站链接可以在settings的<strong>GitHub Pages</strong>看到，也可以去action里看到。</p><h2 id="4-修改Hexo主题样式">4. 修改Hexo主题样式</h2><p>在hexo中找到你需要的主题，然后按照主题修改即可。<br>我放一个链接，这里可以找到很多主题。<br><a href="https://hexo.io/themes/">Hexo主题</a></p><h2 id="5-配置添加文章">5. 配置添加文章</h2><h3 id="5-1推荐用vscod插件">5.1推荐用vscod插件</h3><p><strong>vscode-hexo和Hexo Utils</strong></p><h3 id="5-2-创建文章">5.2 创建文章</h3><p>你可以执行下列命令来创建一篇新文章或者新的页面。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>您可以在命令中指定文章的布局（layout），默认为 post，可以通过修改 _config.yml 中的 default_layout 参数来指定默认布局。</p><p>文章添加编辑后，现在只需要推送到仓库，那么github不仅会保存你的Hexo个人博客源码，还会自动更新个人博客静态页面到gh-pages，由此触发github-page功能来更新你的个人博客网站。</p><h2 id="6-遇到的问题和解决方法">6. 遇到的问题和解决方法</h2><h3 id="6-1-网站没有样式问题">6.1. 网站没有样式问题</h3><p>在网站打开F12，发现css等样式资源无法加载，仔细查看报错原因和请求地址，发现并不是当前仓库。</p><p>缺少仓库地址，所以把请求地址复制一份，并在后面添加上仓库名即可，这需要修改_config.yml中修改url字段。yourusername似乎为小写。</p><p>推送后等待工作流执行，查看结果。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">url:</span> <span class="hljs-string">https://yourusername.github.io/your-repo</span><br><span class="hljs-attr">root:</span> <span class="hljs-string">/your-repo/</span><br></code></pre></td></tr></table></figure><h3 id="6-2-图片不显示">6.2. 图片不显示</h3><p>在_config.yml中设置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">post_asset_folder:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>意思是每个md博文会单独配套一个同名文件夹，用来存放图片。形如</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">source</span><span class="hljs-regexp">/_posts/</span><br>├── my-<span class="hljs-keyword">new</span>-post.md<br>└── my-<span class="hljs-keyword">new</span>-post/<br>    └── example.jpg<br></code></pre></td></tr></table></figure><p>hexo提供三种语法</p><figure class="highlight django"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">asset_path</span> slug %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">asset_img</span> slug [title] %&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><span class="hljs-template-tag">&#123;% <span class="hljs-name">asset_link</span> slug [title] %&#125;</span><br></code></pre></td></tr></table></figure><p>那么在md中可以这样引用图片</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&#123;<span class="hljs-symbol">%</span> asset_img <span class="hljs-built_in">example</span>.jpg This <span class="hljs-built_in">is</span> an <span class="hljs-built_in">example</span> <span class="hljs-built_in">image</span> <span class="hljs-symbol">%</span>&#125;<br></code></pre></td></tr></table></figure><p>具体的可以看这个<a href="https://hexo.io/zh-cn/docs/index.html">Hexo文档</a></p><p>这样一来，部署的时候图片就不会不显示了，但是有个新的问题，<br>我在本地编辑md的时候无法预览图片怎么办。</p><p>建议用VSCode下载插件vscode-hexo和Hexo Utils，随后在左边栏目就可以看到新Hexo Utils的新菜单，只要你的VSCode当前打开的文件夹是hexo的根目录，那么插件就会自动识别到，当你对md文件使用“侧边预览”时，图片就正常显示了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java入门</title>
    <link href="/pingpinghome/2024/07/20/java%E5%85%A5%E9%97%A8/"/>
    <url>/pingpinghome/2024/07/20/java%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h1>1. java入门</h1><h2 id="2-java基础（两个月）">2. java基础（两个月）</h2><p>对于java入门，我这里主要介绍一些java的语法，以及一些java的常用类。<br>主要学习的路径：黑马程序员Java基础<a href="https://www.bilibili.com/video/BV17F411T7Ao/?spm_id_from=333.337.search-card.all.click&amp;vd_source=05a13de36acabb86d2e8a4290b817d96">视频链接</a><br>回想起来，大概学了有两个月，基础很重要，一开始很难，总觉得哪哪都不懂，但越学越快，基础越好，之后学习其他的语言和技术就都很简单。</p><h2 id="3-javaweb（一个半月）">3. javaweb（一个半月）</h2><p>对与javaweb来说，我感觉是一个阶段性的提升，在学习javaweb之前，只能用java进行一些简单的，纯代码的成绩管理系统，这种无法直接使用的东西；<br>虽然这样也让学习没有那么枯燥，但终究会觉得没有什么用。</p><p>只有学习到javaweb之后，我才可以说，java确实是有趣的。<br>学的每一个用法都可以清晰的看到底层原理，并且可以自己进行一些简单的项目，比如，一个简单的成绩管理系统，一个简单的留言板等等。</p><p>主要学习路径：黑马程序员Javaweb<a href="https://www.bilibili.com/video/BV1yGydYEE3H/?vd_source=05a13de36acabb86d2e8a4290b817d96">视频链接</a></p><p>听说他们最近出了一个ai版本的，我没有去了解。因为我觉得学习阶段，还是脚踏实地的好，直接上ai，很多东西你没有亲自去做，就很容易忘记，甚至没了ai，你都不知道如何开发。我认为，这是致命的。</p><p><strong>ai是辅助，但不能是全部。</strong></p><p>事实上，等我学完了单体项目之后，我也会用一点ai，来对自己的代码进行优化和提示，但我一般都不喜欢直接用ai开发。思路不同可以解决，但是代码风格，代码的规范，代码的逻辑会和你自己想的有出入。这让开发过程有些磕磕碰碰，具体看你们喜不喜欢了。<br>之后我也想给自己的博客加一点ai，试试能不能实现一些简单的功能。比如ai总结文章，ai翻译和搜索等。</p><h2 id="4-单体项目（直到目前）">4. 单体项目（直到目前）</h2><p>对于单体项目，简单来说，就是基于之前学习的知识，开始利用框架和一些组件，真正的开始开发一个软件和网站。具体来说呢，基础已经扎实，开始学习对接现代技术了。如：springboot、mybatis、jwt、redis、element、axios、oss、typescript、mysql等。学习后端的，在这里也开始接触前端，我的前端也是在这个时候开始接触的，微信小程序也是在这个阶段开始接触。</p><p>除开学校的项目和课程，我目前正在学习一些新的技术，比如：vue3、springBoot、mybatis、jwt、redis、element、axios、nodejs、typescript、mysql、微信小程序等。这些都已经可以熟练的使用，区别在于，用的多不多。</p><p>这个阶段我认为是最有意思的一个阶段，也是在这个阶段之后，我认为我已经入门了很多东西了。也是在这之后，我才有了实习的想法。因为外面的知识已经没有多少新的了，需要进入公司才可以更进一步。</p><p>学完这些，其实已经可以开始找实习了，因为路就在那里。</p><p>链接就不贴了，因为在这里开始，学的东西都是按照兴趣来的。什么黑马，尚硅谷，菜鸟，官方文档等待，有兴趣就去学，没兴趣我贴一百个链接都没有用。</p><p>最后说一些简单的话，这一行我还没有入行，很多话都只能听听，我只是做一个分享，之后若是入职，会更新我的博客。</p><p>2025-03-20 19:08:41</p>]]></content>
    
    
    <categories>
      
      <category>阶段总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习过程</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
